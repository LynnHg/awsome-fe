# 面试题

## 浏览器是如何渲染页面的？

当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。

在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。

-------

整个渲染流程分为多个阶段，分别是： HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、画

每个阶段都有明确的输入输出，上一个阶段的输出会成为下一个阶段的输入。

这样，整个渲染流程就形成了一套组织严密的生产流水线。

-------

渲染的第一步是**解析 HTML**。

解析过程中遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析前，会启动一个预解析的线程，率先下载 HTML 中的外部 CSS 文件和 外部的 JS 文件。

如果主线程解析到`link`位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。

如果主线程解析到`script`位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。

第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。

-------

渲染的下一步是**样式计算**。

主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 Computed Style。

在这一过程中，很多预设值会变成绝对值，比如`red`会变成`rgb(255,0,0)`；相对单位会变成绝对单位，比如`em`会变成`px`

这一步完成后，会得到一棵带有样式的 DOM 树。

--------

接下来是**布局**，布局完成后会得到布局树。

布局阶段会依次遍历 DOM 树的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。

大部分时候，DOM 树和布局树并非一一对应。

比如`display:none`的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。还有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。

-----------

下一步是**分层**

主线程会使用一套复杂的策略对整个布局树中进行分层。

分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。

滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过`will-change`属性更大程度的影响分层结果。

---------

再下一步是**绘制**

主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。

------

完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。

合成线程首先对每个图层进行分块，将其划分为更多的小区域。

它会从线程池中拿取多个线程来完成分块工作。

----

分块完成后，进入**光栅化**阶段。

合成线程会将块信息交给 GPU 进程，以极高的速度完成光栅化。

GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。

光栅化的结果，就是一块一块的位图

---------

最后一个阶段就是**画**了

合成线程拿到每个层、每个块的位图后，生成一个个「指引（quad）」信息。

指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。

变形发生在合成线程，与渲染主线程无关，这就是`transform`效率高的本质原因。

合成线程会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。

## 什么是 reflow？

reflow 的本质就是重新计算 layout 树。

当进行了会影响布局树的操作后，需要重新计算布局树，会引发 layout。

为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。

也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。

浏览器在反复权衡下，最终决定获取属性立即 reflow。

## 什么是 repaint？

repaint 的本质就是重新根据分层信息计算了绘制指令。

当改动了可见样式后，就需要重新计算，会引发 repaint。

由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。

## 为什么 transform 的效率高？

因为 transform 既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个「draw」阶段

由于 draw 阶段在合成线程中，所以 transform 的变化几乎不会影响渲染主线程。反之，渲染主线程无论如何忙碌，也不会影响 transform 的变化。

## axios
### 说说axios的实现原理
Axios 是一个基于 Promise 的 HTTP 库，可以用于浏览器和 Node.js 环境。它的实现原理主要包括以下几个方面：

1. 基于 XMLHttpRequest (浏览器) 和 http (Node.js)：在浏览器端，Axios 使用 XMLHttpRequest 对象与服务器进行通信。在 Node.js 环境下，Axios 使用 http 模块与服务器进行通信。

2. Promise：Axios 使用 Promise 对象处理异步操作，这使得我们可以利用链式调用（.then() 和 .catch()）来处理请求的成功和失败。Promise 可以让我们更容易地组织和处理异步代码。

3. 拦截器：Axios 提供了请求和响应拦截器，允许我们在请求发送到服务器之前或响应到达客户端之前对其进行处理。这在很多场景下非常有用，比如在请求中统一添加 token，或者在响应中统一处理错误信息。

4. 转换请求和响应数据：Axios 允许我们在请求发送前和处理响应数据时对数据进行转换。这在很多场景下非常有用，比如序列化请求数据，或者对响应数据进行处理以满足特定的需求。

5. 取消请求：Axios 提供了取消请求的功能，这在某些场景下非常有用，比如用户在请求未完成时就切换到了其他页面，我们可以取消未完成的请求以节省资源。

6. 自动转换 JSON 数据：Axios 在处理请求和响应时会自动将 JSON 数据转换为 JavaScript 对象，这让我们在处理数据时更加方便。

7. 并发请求：Axios 提供了 axios.all() 和 axios.spread() 方法来处理并发请求，这可以让我们更方便地处理多个请求并行发送的场景。

总之，Axios 的实现原理主要是基于浏览器和 Node.js 的底层通信能力，结合 Promise、拦截器、数据转换等特性，提供了一个易用且功能丰富的 HTTP 请求库。

### axios怎么判断浏览器环境和node环境
axios在两种环境（浏览器环境和 Node.js 环境）选择不同的适配器（adapter）来判断当前的运行环境，从而在底层实现上作出区分。具体实现如下：

在axios源码中，adapter是处理HTTP请求的核心。浏览器环境使用 `xhr.js`，node环境使用 `http.js`（基于Node.js的http模块）作为adapter。

```js
// 默认配置
const defaults = {
  adapter: getDefaultAdapter(),
  
  //... 其他配置项
};
```

其中 `getDefaultAdapter` 函数会根据情况，返回对应环境的 adapter：

```js
function getDefaultAdapter() {
  let adapter;
  // 仅在Node.js环境中可用的对象
  if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // Node.js环境（服务器端）
    adapter = require('./adapters/http'); // 使用http.js 适配器
  } else if (typeof XMLHttpRequest !== 'undefined') {
    // 浏览器环境（客户端）
    adapter = require('./adapters/xhr');   // 使用xhr.js 适配器
  }
  return adapter;
}
```

从这段代码中可以看出，axios如何判断浏览器环境（判断 XMLHttpRequest 是否存在）和 Node.js 环境（判断 process 是否存在）：

- 浏览器环境会使用`XMLHttpRequest`对象，检查`XMLHttpRequest`是否在全局环境中存在，存在就说明是浏览器环境。
- 对于Node.js环境，会检查`process`对象是否存在，存在则说明是Node.js环境。

通过这种方法，axios 在运行时就能确定适配器采用哪个实现。所以axios能在浏览器和Node.js环境下正常工作。

### 拦截器怎么实现的？
拦截器是 axios 提供的一个强大功能，它允许开发者在请求或响应发送和被处理之前进行一些处理。拦截器实现原理主要是通过链式调用和队列机制。

axios 内部实现了两个拦截器队列：`request.interceptors` 和 `response.interceptors`。拦截器的本质是中间件，中间件的设计模式在 axios 中通过 AOP（面向切面编程）的思想实现。

下面是处理拦截器的核心代码片段：

```js
axios.interceptors.request.use((request) => {
  // 处理请求
}, (error) => {
  // 处理请求错误
});

axios.interceptors.response.use((response) => {
  // 处理响应数据
}, (error) => {
  // 处理响应错误
});
```

当使用 `axios.interceptors.request.use` 或 `axios.interceptors.response.use` 拦截器方法时，会将对应的成功回调函数和失败回调函数添加到队列中。在 dispatchRequest 内部，会通过 `chain` 方法将这些回调函数进行链式调用（Promise链）。

```js
// 在 dispatchRequest 中执行 chain
let chain = [dispatchRequest, undefined];
let promise = Promise.resolve(config);

axios.interceptors.request.forEach(interceptor => {
  chain.unshift(interceptor.fulfilled, interceptor.rejected);
});

axios.interceptors.response.forEach(interceptor => {
  chain.push(interceptor.fulfilled, interceptor.rejected);
});

while (chain.length) {
  // 链式调用
  promise = promise.then(chain.shift(), chain.shift());
}
```

整个实现过程如下：

1. 创建 `request` 和 `response` 拦截器队列。
2. 使用 `use` 方法注册拦截器，将回调函数（成功和失败）添加到相应队列中。
3. 当发出请求时，通过 dispatchRequest 函数将注册的拦截器队列处理成一个链式调用的 Promise 链。
4. 链式调用按照队列顺序逐个执行成功回调和失败回调。
5. 最终得到经过拦截器处理的请求和响应数据。

这样就实现了在请求发送之前和响应被处理之前可以对其进行修改、处理的功能，达到了拦截器的目的。

## Vue
### 讲讲Vue2的响应式原理
Vue 2 的响应式原理主要包括以下几个关键概念：观察者（Observer）、依赖收集（Dep）和监听者（Watcher）。

1. 观察者 Observer：通过递归的方法将一个对象的每个属性都转换成可观察对象，并为每个属性创建一个依赖收集器 Dep。

2. 依赖收集 Dep：Dep 的作用是负责收集所有属性的监听者 Watcher。同时，它负责通知监听者进行视图更新。

具体的响应式原理可以分为以下几步：

1. 当实例化 Vue 时，Vue 会对数据对象 data 进行遍历，并通过 Object.defineProperty 对其属性值进行递归监控。当属性值发生变化时，对应的观察者（Observer）会启动对依赖的通知机制。

2. 在组件模板渲染时，渲染函数将组件所需要的 data 上的属性读取。这时，会触发 `Object.defineProperty` 中的 getter 函数。getter 函数负责收集所有依赖该属性的监听者 Watcher。

3. 当 data 上的属性值发生变化时，会触发 `Object.defineProperty` 中的 setter 函数。setter 函数会通知观察者 Observer，随后观察者 Observer 会通知其管理的依赖收集器 Dep 更新。然后，依赖收集器 Dep 会通知所有监听者 Watcher 去执行相应的更新函数，从而导致视图更新。

总结起来，Vue 2 的响应式原理主要是通过 Object.defineProperty 进行数据劫持，使用观察者 Observer 对数据进行监听，依赖收集 Dep 进行依赖管理和监听者 Watcher 进行视图更新。当数据变化时，触发 getter 函数收集依赖，setter 函数更新视图。

### 使用Object.defineProperty有什么缺点？
使用 Object.defineProperty 的缺点如下：

1. 深度嵌套的对象性能问题：在 Vue 2 中，对象属性的每一层都需要使用递归方法进行逐个遍历，然后使用 Object.defineProperty 对属性进行劫持。这种方式会给深度嵌套的对象带来性能问题，特别当数据量较大时，递归遍历的效率可能受到很大影响。

2. 数组数据劫持的局限性：Object.defineProperty 为数组提供的劫持能力有限，它不能很好地处理数组方法（如 push、pop、splice 等）的监听。Vue 2 对这类问题是通过重写这些方法来实现监听，但这也带来了一定的局限性。

3. 需要初始化时立即递归整个对象树：由于 Object.defineProperty 的特性，Vue 2 必须在初始化时遍历整个对象树，这个过程可能会对性能造成一定的影响。

4. 无法直接监听属性的添加和删除：Object.defineProperty 只能劫持已经存在的属性，所以它无法检测属性的添加和删除。Vue 2 可以使用 Vue.$set 和 Vue.$delete 方法来解决此问题，但这种方式不够直观和方便。

5. 开发环境中的限制：对于一些旧的 JavaScript 引擎（如 IE8 及其之前版本），Object.defineProperty 无法监听对象的属性，导致在这类环境中无法完整运行。

由于这些缺点，Vue 3 中引入了基于 Proxy 的响应式系统来替代 Object.defineProperty，从而优化性能和避免上述问题。
### vue3的响应式和Vue2有什么不同？
Vue 3 的响应式原理和 Vue 2 的主要区别在于数据劫持的实现方式。Vue 3 使用了 ES6 的 Proxy 对象来代替 Vue 2 中的 Object.defineProperty 进行数据劫持。

以下是 Vue 3 的几个关键特点:

1. 使用 Proxy 对象实现数据劫持：Proxy 为数据提供了完全的劫持能力，它支持对数组和对象的直接劫持，同时不需要递归遍历对象属性。这使得 Vue 3 在性能上相比 Vue 2 有明显的优势，特别是在处理大量嵌套属性的场景下。

2. 使用 Reactive 和 Ref 类型：在 Vue 3 中，使用新的 Reactive 和 Ref 类型替代 Vue 2 中的 Observer。Reactive 是为对象而生的响应式数据类型，Ref 专门为基本数据类型设计。在 Vue 3 中，使用 reactive 函数和 ref 函数进行响应式数据处理。

3. 更细粒度的更新策略：Vue 3 中基于 Proxy 实现了更细粒度的更新策略，可以跳过不需要更新的属性。这在复杂的组件系统中可以提升渲染性能。

总结来说，Vue 3 相较于 Vue 2 的最大变化就是使用 Proxy 对象替代 Object.defineProperty，从而改善性能和提供更细粒度的数据劫持。同时，Vue3 引入了 Reactive 和 Ref 类型，使得更加灵活的数据响应式操作成为可能，提升整体的开发体验。